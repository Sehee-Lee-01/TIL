# 1.2 프로그래밍 패러다임

- 학습 내역
  - 2023.03.13 학습

**프로그래밍 패러다임**(Programming Paradigm)은 프로그래머에게 프로그래밍의 관점을 갖게 해주는 역할을 하는 **개발 방법론**입니다.

![Untitled](1%202%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%80%E1%85%B3%E1%84%85%E1%85%A2%E1%84%86%E1%85%B5%E1%86%BC%20%E1%84%91%E1%85%A2%E1%84%85%E1%85%A5%E1%84%83%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%B7%20cb2735d4b14d433f96747b1345ebe6c4/Untitled.png)

# 1.2.1 선언형과 함수형 프로그래밍

- **선언형 프로그래밍(Declarative Programming)**
  - ‘무엇을’ 풀어내는가에 집중하는 패러다임
- **함수형 프로그래밍(Functional Programming)**
  - 선언형 패러다임의 일종
  - **순수 함수**들을 블록처럼 쌓아 로직을 구현하고 **고차 함수**를 통해 재사용성을 높인 프로그래밍 패러다임
    - **순수 함수:** 출력이 입출력에만 의존하는 함수
    - **고차 함수:** 함수가 함수를 값처럼 매개변수로 받아 로직을 생성할 수 있는 것이다.
  - 예시
    - 자바스크립트는 함수가 **일급 객체**이기 때문에 객체지향 프로그래밍 보다는 함수형 프로그래밍 방식이 선호된다.
      - **일급 객체:** 고차 함수를 쓰기 위해서는 해당 언어가 일급 객체하는 특징을 가져야한다.
        - 변수나 매서드에 함수를 할당할 수 있다.
        - 함수 안에 함수를 매개변수로 담을 수 있다.
        - 함수가 함수를 반환할 수 있다.
  ```jsx
  const ret = [1, 2, 3, 4, 5, 11, 12].reduce(
    (max, num) => (num > max ? num : max),
    0
  );
  console.log(ret); // 12
  ```

# 1.2.2 객체지향 프로그래밍

- **객체지향 프로그래밍(OOP, Object-Oriented Programming)**은 객체들의 집합으로 프로그램의 상호 작용을 표현하며 데이터를 객체로 취급하여 객체 내부에 선언된 매서드를 활용하는 방식을 말합니다.
- 설계에 많은 시간이 소요되며 처리 속도가 다른 프로그래밍 패러다임에 비해 상대적으로 느립니다.
- 특징
  - **추상화(Abstraction):** 복잡한 시스템으로부터 핵심적인 개념 또는 기능을 간추려내는 것
  - **캡슐화(Encapsulation):** 객체의 속성과 매서드를 하나로 묶고 일부를 외부에 감추어 은닉하는 것
  - **상속성(Inheritance):** 상위 클래스의 특성을 하위 클래스가 이어받아서 재사용하거나 추가, 확장하는 것
  - **다형성(Polymorphism):** 하나의 매서드나 클래스 가 다양한 방법으로 동작하는 것
    - **오버로딩(Overloading)**
      - 같은 이름을 가진 매서드를 여러 개 두는 것
      - 매개변수의 유형, 개수 등으로 여러 개를 둘 수 있다.
      - 정적 다형성
    - **오버라이딩(Overriding, Method Overriding)**
      - 상위 클래스로부터 상속받은 매서드를 하위 클래스가 재정의하는 것
      - 동적 다형
- 설계 원칙(**SOLID** 원칙)
  - **단일 책임 원칙(S: SRP, Single Responsibility Principle)**
    - 모든 클래스는 각각 하나의 책임만 가져야 한다.
  - **개방-폐쇄 원칙(O: OCP, Open Closed Principle)**
    - 유지 보수 사항이 생긴다면 코드를 쉽게 확장할 수 있도록 하고, 수정할 때는 닫혀 있어야 한다.
    - 기존 코드는 잘 변경하지 않으면서도 확장은 쉽게 할 수 있어야 한다.
  - **리스코프 치환 원칙(L: LSP, Liskov Substitution Principle)**
    - 프로그램의 객체는 프로그램의 정확성을 깨뜨리지 않으면서 하위 타입의 인스턴스로 바꿀 수 있어야 한다.
    - 부모 객체와 자식 객체를 바꿔도 문제가 없어야 한다.
  - **인터페이스 분리 원칙(I: ISP, Interface Segregation Principle)**
    - 하나의 일반적인 인터페이스보다 구체적인 여러 개의 인터페이스를 만들어야한다.
  - **의존 역전 원칙(D: DIP, Dependency Inversion Principle)**
    - 자신보다 변하기 쉬운 것에 의존하던 것을 추상화된 인터페이스나 상위 클래스를 두어, 변하기 쉬운 것의 변화에 영향 받지 않게 한다.
    - 상위 계층은 하위 계층의 변화에 대한 구현으로부터 독립해야 한다.
- 예시
  ```jsx
  const ret = [1, 2, 3, 4, 5, 11, 12];
  class List {
    constructor(list) {
      this.list = list;
      this.mx = list.reduce((max, num) => (num > max ? num : max), 0);
    }
    getMax() {
      return this.mx;
    }
  }
  const a = new List(ret);
  console.log(a.getMax()); // 12
  ```

# 1.2.3 절차형 프로그래밍

- 절차형 프로그래밍(Procedural Programming)은 로직이 수행되어야 할 연속적인 계산 과정으로 이루어져 있습니다.
- 일이 진행되는 방식으로 코드를 구현합니다.
- 계산이 많은 작업 등에 쓰입니다.

# 1.2.4 패러다임의 혼합

- 각 패러다임의 특징을 생각하고, 여러 패러다임을 조합하여 사용하는 것도 좋다.
