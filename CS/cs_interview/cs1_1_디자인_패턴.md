> 주홍철님의 [‘면접을 위한 CS 전공지식 노트’](https://github.com/wnghdcjfe/csnote)를 읽고 정리한 페이지입니다.

# 1.1 디자인 패턴

- 학습 내역
  - 2023.03.06 옵저버 패턴까지 학습
  - 2023.03.13 MVVM 패턴까지 학습

## 디자인 패턴이란?

프로그램을 설계할 때 발생했던 문제점들을 객체 간의 상호 관계 등을 이용하여 해결할 수 있도록 하나의 ‘**규약**’ 형태로 만들어 놓은 것을 의미한다. 각종 라이브러리와 프레임워크의 기본이 된다.

## 1.1.1 싱글톤 패턴(Singleton Pattern)

- 하나의 클래스에 **오직 하나의 인스턴스**만 가지는 패턴이다.
  - 보통 **데이터베이스 연결 모듈**에 많이 사용한다.
  - 인스턴스 생성 비용이 줄어드는 장점이 있다.
  - 의존성(종속성)이 높아진다는 단점이 있다.
- **의존성 주입(DI, Dependency Injection)**
  - 위의 문제점을 모듈 간의 결합을 조금 더 느슨하게 만들어 해결하는 방법
  - **메인 모듈**이 **직접** 다른 하위 모듈에 대한 의존성을 주는 것보다는 중간에 **의존성 주입자(Dependency Injector)**가 이 부분을 가로채 메인 모듈이 **간접**적으로 의존성을 주입하는 방식이다. 메인 모듈(상위 모듈)은 하위 모듈에 대한 의존성이 떨어지게 된다(디커플링).
  - **장점**
    - 모듈을 쉽게 교체할 수 있다. 테스팅 하기 쉽다. 마이그레이션이 수월하다.
    - 애플리케이션의 의존성 방향이 일관화된다. 애플리케이션을 쉽게 추론 가능하다. 모듈 간의 관계가 명확해진다.
  - **단점**
    - 모듈이 분리되어서 복잡성 증가 가능성이 높아짐
    - 약간의 런타임 패널티가 생기기도 한다.
  - **원칙**
    - 상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야 한다.
    - 두 모듈 모두 추상화에 의존해야 한다. 추상화는 세부 사항에 의존하지 말아야한다.
      ![Untitled](1%201%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%20ebdf7b3a11f147c1a7ae1b72dd69cd51/Untitled.png)
- 의존성 주입 **예시**
  Chat GPT: 의존성 주입 예시를 알려줘

  - 의존성 주입(Dependency Injection)은 객체 지향 프로그래밍에서 객체 간의 결합도(Coupling)를 낮추기 위해 사용하는 디자인 패턴 중 하나입니다. 객체 지향 프로그래밍에서 객체는 다른 객체와 상호작용하면서 동작하는데, 이때 객체 간의 의존성이 발생합니다. 의존성 주입은 이러한 객체 간의 의존성을 외부에서 설정하도록 하는 방식으로, 객체 간의 결합도를 낮춰 유지보수성과 확장성을 높이는 데에 도움을 줍니다.
  - 의존성 주입에는 크게 생성자 주입(Constructor Injection), 세터 주입(Setter Injection), 인터페이스 주입(Interface Injection) 등의 방법이 있습니다.
    아래는 생성자 주입을 사용한 예시입니다.

  ```python
  # 요약: UserService에서 직접 UserRepository 객체를 생성하는 것이 아니라 외부에서 생성된 UserRepository를 사용한다.

  class UserService:
      def __init__(self, user_repository):
          self.user_repository = user_repository

      def get_user(self, user_id):
          return self.user_repository.get(user_id)

  class UserRepository:
      def __init__(self, db_connection):
          self.db_connection = db_connection

      def get(self, user_id):
          query = f"SELECT * FROM users WHERE id={user_id}"
          return self.db_connection.execute(query)

  ''' 위 코드에서 UserService 클래스는 UserRepository 클래스에 의존합니다. UserRepository 객체를 생성하기 위해서는 데이터베이스 연결을 위한 db_connection 객체가 필요합니다. 하지만 UserService 클래스에서는 UserRepository 객체만을 직접 생성하고 사용하게 되면, 나중에 데이터베이스 연결 방식이 변경되었을 때 UserService 클래스를 수정해야 하는 문제가 생깁니다.

  이를 해결하기 위해서 UserService 클래스에서는 UserRepository 객체를 생성하는 대신 외부에서 생성된 UserRepository 객체를 인자로 받도록 변경합니다. 이렇게 하면 UserRepository 객체를 생성하는 방식이 변경되어도 UserService 클래스를 수정하지 않아도 됩니다. '''

  db_connection = DatabaseConnection()
  user_repository = UserRepository(db_connection)
  user_service = UserService(user_repository)

  ''' 이렇게 하면 UserRepository 클래스를 생성할 때 db_connection 객체를 직접 전달하고, 이를 다시 UserService 클래스에 전달함으로써 객체 간의 의존성을 외부에서 설정할 수 있습니다. '''
  ```

## 1.1.2 팩토리 패턴(factory pattern)

- 객체를 사용하는 코드에서 **객체 생성 부분을 떼어내 추상화**한 패턴이다.
- **상속 관계**에 있는 두 클래스에서 **상위 클래스가 중요한 뼈대**를 결정하고, **하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정**하는 패턴이다.
- 장점
  - 상위 클래스, 하위 클래스가 분리되기 때문에 느슨한 결합을 가진다.
  - 상위 클래스에서는 인스턴스 생성 방식에 대해 전혀 알 필요가 없다.
  - 객체 생성 로직이 분리되어 코드를 리펙터링하더라도 한 곳만 고칠 수 있게 된다.

## 1.1.3 전략 패턴(Strategy Pattern, Policy Pattern)

- 객체의 행위를 바꾸고 싶은 경우 **직접** 수정하지 않고 전략이라고 부르는 **캡슐화한 알고리즘**을 컨텍스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴이다.
- 예시
  - passport 라이브러리
    - Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리로, 여러 가지 **전략**을 기반으로 인증할 수 있게 한다.
    - 전략의 종류
      - LocalStrategy: 서비스 내 회원가입 정보
      - OAuth: 페이스북, 네이버 등 소셜 로그인

## 1.1.4 옵저버 패턴(Observer Pattern)

- **주체가 어떤 객체의 상태 변화를 관찰**하다가 **상태 변화**가 있을 때마다 매서드 등을 통해 옵저버 목록에 있는 **옵저버들에게 변화를 알려주는** 디자인 패턴이다.
  - **주체**: 객체의 상태 변화를 보고 있는 관찰자(주체와 객체를 따로 두지 않는 경우고 있다.)
  - **옵저버**: 객체의 상태 변화에 따라 전달되는 매서드 등을 기반으로 **추가 변화 사항**이 생기는 객체들
- 주로 이벤트 기반 시스템에 사용한다. MVC 패턴에도 사용된다.
  - 트위터 등
- 옵저버 패턴을 구현하는 법
  - 주로 **프록시 객체**를 써서 구현한다.
    - 프록시 객체를 통해 **객체의 속성이나 메서드 변화 등을 감지**하고 이를 미리 설정해 놓은 옵저버들에게 전달하는 방법

## 1.1.5 프록시 패턴(Proxy Pattern)과 프록시 서버

- **프록시 패턴**
  - 대상 객체에 접근하기 전 그 접근에 대한 흐름을 가로채 대상 앞단의 인터페이스 역할을 하는 디자인 패턴입니다.
- **프록시 서버**
  - 서버와 클라이언트 사이에서 클라이언트가 자신을 통해 다른 네트워크 서비스에 **간접적으로** 접속할 수 있게 해주는 컴퓨터 시스템이나 응용 프로그램입니다.
  - 서버 앞단에 둬서 캐싱, 로깅, 데이터 분석을 서버보다 먼저 하는 서버입니다.
  - 특징
    - 포트 번호를 바꿔서 사용자가 실제 서버 포트에 접근하지 못하게 할 수 있다.
    - DDOS 공격 차단
    - CDN을 프록시 서버로 달아서 캐싱 처리
  - 응용 프로그램 예시
    - Nginx
      - 주로 Node.js 서버 앞단의 프록시 서버로 활용
      - 버퍼 오버플로우 해결
    - CloudFlare
      - https, 캐싱, 로그 분석 등을 용이하게 해줌
- CORS 참고 영상
  - 요약
    - 보통 프론트, 백 둘 다 CORS 설정을 할 수 있지만, 프론트보다 **서버(백엔드**)에서 CORS 설정을 해준다. White List를 만들어 허용되는 오리진 목록을 만들어 놓고 개발한다.

[https://www.youtube.com/watch?v=j2Q2Ev6CZzQ&t=361s](https://www.youtube.com/watch?v=j2Q2Ev6CZzQ&t=361s)

## 1.1.6 이터레이터 패턴(Iterator Pattern)

- 이터레이터를 사용하여 컬렉션의 요소들에 접근하는 디자인 패턴입니다.
- 순회할 수 있는 자료구조라면 구조에 상관없이 하나의 인터페이스로 순회가 가능합니다.

## 1.1.7 노출 모듈 패턴(Revealing Module Pattern)

- 즉시 실행 함수를 통해 private, public 같은 접근 제어자를 만드는 패턴을 말합니다.

## 1.1.8 MVC 패턴

- 모델(Model), 뷰(View), 컨트롤러(Controller)로 이루어진 디자인 패턴입니다.
- 어플리케이션 구성 요소를 세 가지 역할로 구분하여 개발 프로세스에서 각각 구성 요소에만 집중할 수 있다.

![Untitled](1%201%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%20ebdf7b3a11f147c1a7ae1b72dd69cd51/Untitled%201.png)

- 구성 요소
  - 모델
    - 애플리케이션의 데이터(DB, 상수, 변수)
  - 뷰
    - 사용자 인터페이스(사용자가 볼 수 있는 화면)
  - **컨트롤러**(중요한 역할)
    - 하나 이상의 모델과 하나 이상의 뷰를 잇는 다리 역할(1:n)을 하며 이벤트 등 메인 로직을 담당
    - 모델과 뷰의 생명주기 관리
    - 모델과 뷰의 변경 통지를 받으면 이를 해석하여 각가의 구성 요소에 해당 내용에 대해 알림
- 예시: 리엑트(React)
  - 가상 DOM을 이용해 실제 DOM을 조작하는 것을 추상화
    - 설명1(🤖ChatGPT: 왜 React가 MVC 패턴인지 알려줘)
      - React는 MVC(Model-View-Controller) 패턴이 아닌, 단방향 데이터 흐름을 강조하는 Flux 아키텍처 패턴의 구현체입니다. **그러나 React는 MVC 패턴의 View 역할을 수행합니다.** React는 컴포넌트 기반의 뷰(View) 렌더링을 위해 사용됩니다. 이를 통해 모델(Model)의 데이터를 뷰(View)에 표시할 수 있습니다.
      - React에서는 모델(Model)과 컨트롤러(Controller) 역할을 하는 Flux 아키텍처 패턴의 구성요소인 Store와 Action을 사용합니다. Store는 데이터를 저장하고 관리하며, Action은 Store의 데이터를 변경하는 요청을 보내는 역할을 합니다.
      - 따라서, **React는 MVC 패턴의 구현체는 아니지만, 뷰(View) 역할을 수행하기 때문에,** React를 MVC 패턴으로 설명하기도 합니다. 그러나, 정확히는 React는 Flux 아키텍처 패턴을 기반으로 하고 있습니다.
    - 설명2((🤖ChatGPT: 더 자세히 이야기해줘)
      - React는 컴포넌트 기반의 라이브러리로, 사용자 인터페이스를 구성하기 위해 설계되었습니다. React에서 컴포넌트는 독립적이고 재사용 가능한 코드 블록으로 구성됩니다. 이를 통해 개발자는 복잡한 UI를 간단한 컴포넌트로 나누어 작성할 수 있습니다.
      - React는 단방향 데이터 흐름을 강조하는 Flux 아키텍처 패턴의 구현체 중 하나입니다. Flux는 양방향 데이터 바인딩의 단점을 해결하기 위해 개발된 패턴으로, 데이터의 흐름이 한 방향으로만 흐르도록 설계되었습니다.
      - MVC 패턴에서는 모델(Model), 뷰(View), 컨트롤러(Controller)로 구성되어 있습니다. 모델은 데이터를 관리하고 처리하는 부분, 뷰는 사용자 인터페이스를 표시하는 부분, 컨트롤러는 모델과 뷰를 연결하는 부분입니다.
      - Flux 패턴에서는 **모델(Model)의 역할을 Store가 담당**합니다. Store는 어플리케이션의 상태를 저장하고, 변경사항을 감지하여 뷰(View)에 전달합니다. 뷰(View)에서는 이벤트가 발생하면 Action을 생성하여 Dispatcher에 전달합니다. Dispatcher는 Store에게 Action을 전달하고, Store는 상태를 업데이트합니다. 이를 통해 뷰(View)는 Store의 상태를 사용하여 업데이트됩니다.
      - **React에서는 뷰(View)의 역할을 컴포넌트가 담당합니다.** 컴포넌트는 상태(State)와 속성(Props)를 가지며, 이를 사용하여 뷰를 렌더링합니다. 상태(State)는 컴포넌트 내에서 변경될 수 있는 데이터를 의미하며, 속성(Props)은 부모 컴포넌트에서 전달된 값입니다.
      - **따라서, React는 MVC 패턴이 아닌 Flux 아키텍처 패턴의 구현체입니다. 그러나 React에서 뷰(View) 역할을 수행하기 때문에, React를 MVC 패턴으로 설명하기도 합니다.**
  - 가상 DOM
    [https://www.youtube.com/watch?v=kP-H1GXD_nI](https://www.youtube.com/watch?v=kP-H1GXD_nI)

## 1.1.9 MVP 패턴

- MVC 패턴으로부터 파생되었으며, MVC에서 C에 해당하는 컨트롤러가 **프레젠터(Presenter)**로 교체된 패턴입니다.
- **뷰와 프레젠터가 1:1 관계**이기 때문에 MVC 패턴보다 **더 강한 결합**을 지닌 디자인 패턴이다.

![Untitled](1%201%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%20ebdf7b3a11f147c1a7ae1b72dd69cd51/Untitled%202.png)

## 1.1.10 MVVM 패턴

- MVC의 C에 해당하는 컨트롤러가 **뷰모델(View Model)**로 바뀐 패턴입니다.
  - 뷰모델: 뷰를 더 추상화한 계층

![Untitled](1%201%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB%20%E1%84%91%E1%85%A2%E1%84%90%E1%85%A5%E1%86%AB%20ebdf7b3a11f147c1a7ae1b72dd69cd51/Untitled%203.png)

- MVC 패턴과는 다르게 **커맨드**와 **데이터 바인딩**을 가지는 것이 특징입니다.
  - **커맨드**: 여러 가지 요소에 대한 처리를 하나의 액션으로 처리할 수 있게 하는 기법이다.
  - **데이터 바인딩**: 화면에 보이는 데이터와 웹 브라우저의 메모리 데이터를 일치시키는 기법으로, 뷰모델을 변경하면 뷰가 변경된다.
  - 뷰와 뷰모델의 양방향 데이터 바인딩을 통해 연결됩니다.(MVP보다 강한 결합X)
  - UI를 별도의 코드 수정 없이 재사용할 수있습니다.
  - 단위 테스팅하기 쉽습니다.
- 예시: 뷰(Vue.js)

> 🤖**ChatGPT: MVC, MVP, MVVM 패턴의 목적의 차이점을 알려줘**
>
> MVC(Model-View-Controller), MVP(Model-View-Presenter), MVVM(Model-View-ViewModel) 패턴은 모두 소프트웨어 **디자인 패턴 중에서 UI 계층에서 많이 사용**되는 패턴입니다. 이들 패턴은 각각 목적과 구조가 다르며, 각각의 장단점이 있습니다.
>
> 따라서, 각각의 패턴은 UI와 데이터 로직을 분리하여 애플리케이션의 구조를 개선하고, 개발 생산성과 코드 품질을 향상시키기 위한 목적을 가지고 있습니다.
>
> 1. **MVC(Model-View-Controller) 패턴**
>    1. MVC 패턴은 UI 컴포넌트를 모델(Model), 뷰(View), 컨트롤러(Controller)로 분리하여 애플리케이션을 보다 유지보수하기 쉽도록 만드는 것이 주요 목적입니다.
>    2. 이 패턴에서는 뷰가 모델에 직접 접근하지 않고, 컨트롤러가 중개자 역할을 하면서 뷰와 모델의 상호작용을 관리합니다.
> 2. **MVP(Model-View-Presenter) 패턴**
>    1. MVP 패턴은 뷰(View), 모델(Model), 프레젠터(Presenter)를 분리하여 뷰와 모델의 결합도를 낮추고, 테스트 용이성을 높이는 것이 주요 목적입니다.
>    2. 뷰는 UI를 표현하고, 모델은 데이터를 처리하며, 프레젠터는 뷰와 모델 사이에서 데이터를 주고받으며 뷰의 상태를 업데이트합니다. 이렇게 하면 뷰와 모델의 변경이 서로 독립적으로 일어날 수 있으며, 각각의 컴포넌트를 개별적으로 테스트할 수 있습니다.
> 3. **MVVM(Model-View-ViewModel) 패턴**
>    1. MVVM 패턴은 뷰(View), 모델(Model), 뷰모델(ViewModel)을 분리하여 UI와 데이터 처리를 분리하는 것이 주요 목적입니다.
>    2. 뷰는 UI를 표현하며, 뷰모델은 뷰의 데이터와 동작을 캡슐화하고, 모델은 데이터를 처리합니다. 이렇게 하면 뷰모델은 뷰의 상태와 데이터 처리를 담당하면서 뷰와 모델 사이에서 중개자 역할을 하게 됩니다.
>    3. 이 패턴에서는 뷰모델과 뷰의 상호작용을 **데이터 바인딩**을 통해 처리하므로, **뷰와 뷰모델 사이의 코드 중복과 결합도**를 낮출 수 있습니다
