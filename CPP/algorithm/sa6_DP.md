# 6. DP

# 1. 수학적 귀납법

- 수학적 귀납법은 주어진 등식이 **n = 1 일 때 성립함**(귀납 기본, induction base)을 증명하고, **n일 때 성립한다고 가정**(귀납 가정, induction hypothesis)한 뒤 **n+1일 때 성립함을 증명**(귀납 단계, induction step)하는 것입니다.

# 2. DP

- DP는 위와 같이 귀납법을 만족하는 **점화식**을 찾아서 **recursive**와 **memoization**을 활용해 문제를 해결하는 방식입니다.
- **최적화 문제**를 해결하는 알고리즘입니다.
  - 작은 부분 문제들의 해를 구하고 이를 이용하여 보다 큰 크기의 부분 문제를 해결해 나가며 최종적으로 원래 주어진 문제를 해결
  - Memoization: 이전에 계산한 값을 메모리에 저장해서 **중복 계산**을 줄여줌
- **두 가지 필수 요건**
  - **최적 부분 문제 구조(Optimal substructure)**
    - DP를 효율적으로 적용하기 위해선 문제가 최적화의 원칙(Principle of Optimality)을 만족해야 합니다. DP 방법이 작은 해의 최적 해를 통해 큰 문제의 최적화를 구하기 때문에 최적화의 원칙을 만족하는 문제가 아니라면 DP를 적용할 수 없습니다.
    - **최적화의 원칙**
      - 어떤 문제에 대한 해가 최적일 때 그 해를 구성하는 작은 문제들의 해 역시 최적이어야 한다는 것입니다.
  - **중복 부분 문제 구조(Overlapping sbproblems)**
    - 큰 문제를 이루는 작은 문제들을 먼저 해결하고 작은 문제들의 최적 해를 이용하여 순환적으로 큰 문제를 해결합니다. 이때 순환적인 관계를 명시적으로 표현하기 위해 **점화식**을 사용합니다.
    - 이전에 계산된 작은 문제의 해가 다른 문제에서 필요하게 되는데(Overlapping subproblems) 이를 위해 이미 해결된 작은 문제들의 해들을 어떤 저장 공간에 저장합니다. 저장된 작은 문제들의 해는 필요할 때마다 다시 계산하는 과정 없이 참조할 수 있기 때문에 중복된 계산을 피하게 만들어줍니다.
