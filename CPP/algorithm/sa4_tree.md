# 4. 트리

: **사이클이 없는** 연결 그래프

# **1. Tree 용어 정리**

**◆ parent node / child node (부모 노드 / 자식 노드)**

- **parent node**: 연결된 두 노드 중 위에 있는 노드
- **child node:** 연결된 두 노드 중 아래에 있는 노드

**◆ ancestor / descendent  (조상 / 자손)**

- 노드 V에서 부모 노드로만 계속 이동해서 노드 U로 갈 수 있는 경우
    - U는 V의 조상
    - V는 U의 자손

**◆ root node (루트)**

- 부모 노드가 없는 노드
- 트리 최상단 위치

**◆ leaf node (리프)**

- 자식 노드가 없는 노드

**◆ depth of a node (깊이)**

- 루트에서 해당 노드까지 이동하기 위해 거쳐야 하는 간선의 개수

**◆ height of a node (높이)**

- 해당 노드부터 가장 먼 리프 노드까지 이동하기 위해 거쳐야 하는 간선의 수

**◆ subtree (서브 트리)**

- 어떤 노드와 부모 노드 간의 연결을 끊으면 해당 노드를 루트 노드로 하는 새로운 트리가 만들어집니다.

**◆ size of tree (트리의 크기)**

- 노드의 개수

# **2. Binary Search Tree**

- 원소의 중복을 허용 X
- 왼쪽 서브 트리는 자기보다 작은 값을, 오른쪽 서브 트리는 자기보다 큰 값을 저장
- C++ std::set에는 Binary Search Tree 중 하나인 Red Black Tree 사용
- 트리의 종류
    - 전 이진 트리(Full Binary Tree)
        - 모든 노드가 0개 또는 2개의 자식 노드를 갖는다.
    
    ![Untitled](4%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20bd0d4c475c6a41e79857b4790a3ad866/Untitled.png)
    
    - 완전 이진 트리(Complete Binary Tree)
        - 마지막 레벨을 제외하고 모든 레벨이 완전히 채워져 있는 트리
        - 노드가 왼쪽에서 오른쪽으로 채워져야 한다.
    
    ![Untitled](4%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20bd0d4c475c6a41e79857b4790a3ad866/Untitled%201.png)
    
    - 포화 이진 트리(Perfect Binary Tree)
        - 포화 이진 트리는 모든 내부 노드가 두 개의 자식 노드를 가진다.
        - 모든 잎 노드가 동일한 깊이 또는 레벨을 갖는다.
    
    ![Untitled](4%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20bd0d4c475c6a41e79857b4790a3ad866/Untitled%202.png)
    
    - 균형 이진 트리(Balanced Binary Tree)
        - 왼쪽과 오른쪽 트리의 높이 차이가 모두 1만큼 나는 트리
    
    ![Untitled](4%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20bd0d4c475c6a41e79857b4790a3ad866/Untitled%203.png)
    

# **3. 초기화(**Binary Search Tree**)**

- 문제 풀 때는 정적 할당 할 수 있도록 하자.

# **4. 삽입(**Binary Search Tree**)**

- **재귀**로 구현하고 데이터가 삽입된 후 **루트 노드**를 리턴 한다.
- 경우의 수
    - 데이터가 비어있는 경우
        - 삽입 데이터가 곧 루트 노드가 된다.
    - 삽입 데이터가 중복되지 않는 경우
        - 재귀를 통해서 삽입한다.
        - 해당 노드 값보다 작으면 왼쪽
        - 해당 노드 값보다 크면 오른쪽
    - 삽입 데이터가 중복되는 경우
        - 아무 작업도 수행하지 않는다.

# **5. 삭제(**Binary Search Tree**)**

- **재귀**로 구현하고 데이터가 삭제된 후 **루트 노드**를 리턴 한다.
- 경우의 수
    - 데이터가 비어있는 경우
        - NULL 리턴
    - node의 왼쪽 자식에서 x를 삭제해야 하는 경우 (x < node->key인 경우)
        - 왼쪽 서브트리에서 x를 삭제한 다음 왼쪽 자식을 그 서브트리의 루트로 바꿔주면 됩니다.
    - node의 key와 x가 같은 경우
        - node를 삭제하고 node의 부모 노드와 node의 자식 노드를 트리 구조에 맞게 이어줘야 합니다.
        - 경우의 수
            - 한 쪽 자식만 있는 경우
            
            ![Untitled](4%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20bd0d4c475c6a41e79857b4790a3ad866/Untitled%204.png)
            
            - 왼쪽 자식, 오른쪽 자식 모두 있는 경우
                - node 자리에는 node의 왼쪽 서브트리의 모든 값보다 크고, node의 오른쪽 서브트리의 모든 값보다 작은 값이 와야 합니다.
                - node의 key를 오른쪽 서브트리에서 가장 작은 key 값으로 바꾸고, 오른쪽 서브트리에서 그 key를 대신 삭제하는 대안을 사용합니다.
                - 왼쪽 서브트리에서 가장 큰 key값을 찾아도 됩니다.

# **6. 탐색**

- 해당 값이 있는지 없는지 검사

# **7. 트리 순회**(자신 노드의 기준으로)

- pre-order (전위 순회)
    - 자신 -> 왼쪽 서브트리 -> 오른쪽 서브트리
- in-order (중위 순회)
    - 왼쪽 서브트리 -> 자신 -> 오른쪽 서브트리
- post-order (후위 순회)
    - 왼쪽 서브트리 -> 오른쪽 서브트리 -> 자신
    - post-order 순회는 자식 서브트리를 모두 방문한 후에 자신을 방문하므로 자식 노드에서 계산된 결과를 자신이 활용할 수 있습니다.
    - 이를 이용한 대표적인 예로 계산기 구현, 세그먼트 트리가 있습니다.
- 재귀로 구현하거나 스택으로 구현할 수 있다.

# 8**. Self-Balanced Binary Search Tree**

![Untitled](4%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%B5%20bd0d4c475c6a41e79857b4790a3ad866/Untitled%205.png)

- 트리를 삽입하다 보면 위와 같이 연결 리스트 구조를 띄는 경우가 생길 수도 있다. 이럴 때는 시간복잡도가 O(노드의 개수)가 된다. **이와 달리, 노드의 개수가 N일 때 트리의 높이가 logN인 트리를 height-balanced하다고 한다.** 이런 트리에서는 삽입/삭제/탐색이 모두 **O(logN)**이 보장된다.
- 원소가 삽입/삭제될 때마다 height-balanced하게 **높이를 조절**하는 Binary Search Tree를 **Self-Balanced Binary Search Tree**라고 합니다.
- 예시: Red-Black Tree, Splay Tree, B-Tree 등