# 12. 트라이

- **문자열 집합**을 관리하는 **트리**
- **간선마다 알파벳 하나가 대응**되고, 자식 노드와 연결된 간선 중 어떤 알파벳과 대응되는 간선은 **최대 하나**입니다.
- 트리를 내려가면서 만나는 간선의 알파벳을 모두 이으면 원래 문자열을 얻을 수 있고, 두 문자열의 **접두사**가 같다면 **그 길이 만큼의 간선을 트리에서 공유**합니다.
  ![download.png](12%20%E1%84%90%E1%85%B3%E1%84%85%E1%85%A1%E1%84%8B%E1%85%B5%20e11c12f4afa0466992edf61a3a7279b4/download.png)
- **T**는 문자열의 **끝**이라는 표시입니다. 루트 노드에서 T 노드로 가는 경로의 알파벳을 이으면 집합에 포함된 문자열을 얻을 수 있습니다.
  - **T 표시가 없다면?** 원래 문자열 집합을 **전부** 뽑아낼 수 없습니다.

# 1. 노드

```cpp
struct TrieNode {
	bool is_terminal;
	// std::map< char, TrieNode*> child; // 첫 번째 방법
	// TrieNode* child[CHAR_NUM]; // 두 번째 방법
};
```

- **is_terminal:** 문자열의 **끝**인지 확인
  - **개수**를 표기하여 원소의 중복을 허용하는 트라이를 만들 수도 있습니다.
- 간선을 저장하는 방법
  - **std::map**에 **사용하는 간선만큼**의 데이터만 저장
    - std::map이 무겁다는 단점
  - **사용되는 문자 종류의 개수만큼** 간선을 만들어서 배열에 저장
    - 사용되는 문자의 종류가 **적다면**(ex. 문자열이 **알파벳 소문자**로만 되어 있을 경우) 효과적

# 2. 트리 내려가기

```cpp
std::string str;

TrieNode* n = root_node;
for (const char& c : str) {
	if (n->child[c] == nullptr) {
		n->child[c] = new_node();
	}
	n = n->child[c];
}
```

- 루트 노드에서 시작하여, 문자열의 문자를 하나씩 보면서 해당하는 간선으로 이동합니다.
  - 간선 너머가 NULL이라면, 즉석에서 새 노드를 만들어서 붙여줍니다.
- 트라이에서의 삽입/삭제/탐색 모두 위의 방식을 기본으로 합니다.

# 3. 활용

- 트라이에서 문자열의 삽입/삭제/탐색은 언제나 **O(문자열의 길이)**입니다.
  - 해시와 같은 시간 복잡도로, 매우 빠릅니다.
- **해시**와의 차이점
  - 해시는 데이터 순서를 무작위로 저장합니다.
  - 트라이도 **트리**의 한 종류이기 때문에 **Binary Search Tree의 동작**을 응용하여 **k번째 문자열 찾기, 같은 접두사를 가지는 문자열 개수 세기** 등 해시 테이블로는 할 수 없는 동작까지 할 수 있습니다.
- 트라이의 공간 복잡도는 **O(삽입된 문자열의 총 길이)** 입니다.
