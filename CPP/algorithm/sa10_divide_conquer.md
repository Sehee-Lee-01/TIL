# 10. 분할 정복

# 1. Merge Sort

![Untitled](10%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AF%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%86%A8%20cf74c3545f324e9cb87babc2791c24fc/Untitled.png)

- 특징
  - Merge Sort는 **항상 O(N∙logN)**의 시간 복잡도를 보장하기 때문에 안정적인 수행속도가 보장되어야 할 때 많이 사용
  - 같은 값끼리 정렬 전후의 순서가 유지되는 Stable Sort
  - 정렬된 두 배열을 합치기 위해 배열의 크기만큼 메모리 공간을 추가로 사용
    <aside>
    📦 추가 공간을 사용하지 않는 **In-Place Merge Sort**도 존재합니다! In-Place Merge Sort는 **연결 리스트(Linked List)**를 사용해서 구현 합니다.
    
    </aside>

- 단계
  - (분할) 정렬되지 않은 리스트를 **절반으로 잘라** 두 개의 리스트로 나눈다.
  - (정복) 생성된 두 개의 리스트를 Merge Sort 알고리즘을 **재귀 호출**하여 정렬한다.
  - (통합) 정렬된 두 개의 리스트를 다시 **하나의 정렬된 리스트로 Merge**한다.

# 2. Quick Sort

![download.png](10%20%E1%84%87%E1%85%AE%E1%86%AB%E1%84%92%E1%85%A1%E1%86%AF%20%E1%84%8C%E1%85%A5%E1%86%BC%E1%84%87%E1%85%A9%E1%86%A8%20cf74c3545f324e9cb87babc2791c24fc/download.png)

- 특징
  - pivot으로 선택된 원소는 반드시 정렬되며 다음 재귀 호출에서 제외되기 때문에 어떻게 pivot을 선택하더라도 올바르게 정렬된다는 것은 보장한다.
  - 추가 공간을 사용하지 않기 때문에 In-Place Sort이다.
  - 평균적으로는 O(N∙logN)의 시간복잡도를 가지지만, pivot으로 리스트 내에서 가장 작은/큰 값을 계속 고른다면 최악의 경우 O(N^2)의 시간 복잡도를 가집니다.
    <aside>
    📦 많은 프로그래밍 언어의 표준 라이브러리의 정렬 함수는 Quick Sort의 높은 성능은 가져오는 대신 최악의 경우를 피하기 위해, Quick Sort와 기타 정렬 방법을 섞은 **Hybrid Sort**를 사용합니다. 예를 들어 g++의 std::sort는 Quick Sort를 사용하다가 재귀가 깊어지면 Heap Sort를 사용하고, 배열의 길이가 충분히 짧다면 Insertion Sort를 사용하는 Intro Sort 방식을 사용합니다.
    
    </aside>

- 단계
  - 리스트 내에 임의의 원소를 선택하여 pivot이라 명합니다.
  - pivot을 기준으로 pivot보다 작은 원소는 좌측으로, pivot보다 큰 원소는 우측으로 이동합니다.
  - pivot을 제외하고 좌측 리스트와 우측 리스트를 Quick Sort 알고리즘을 재귀 호출하여 정렬합니다.

# 3. 거듭제곱 계산

- X^Y를 계산하는 두 가지 방법(Y가 엄청 큰 수일 때, 여기서는 Y=1024라고 가정)
  - X를 1024번 곱하기
  - X^1024 = X^512 ∙ X^512 식으로 나누어 곱하기
    - X^Y를 O(logY) 시간에 구할 수 있다.
