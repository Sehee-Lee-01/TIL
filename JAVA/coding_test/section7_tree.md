# 트리

> [Do it! 알고리즘 코딩테스트 with JAVA](https://inf.run/yax9)를 수강하며 기록했습니다.

## 1. 트리

### 1) 특징

- `그래프`의 표현으로도 tree를 만들 수 있다.
- 트리에서 임의의 두 노드를 이어주는 경로는 유일하다.

### 2) 팁

- 그래프로 푸는 tree

  - 인접 리스트로도 표현할 수 있다.
    - DFS, BFS 응용

- `tree만을 위한 문제`
  - 고급 문제: 이진트리, 세그먼트 트리(인덱스 트리), ACL(최소 공통 조상)
    - 1차원 배열로 tree 표현

## 2. 이진 트리

### 1) 이진 트리

- 각 노드의 자식노드가 `2개 이하`로 구성된 트리
- 1차원 배열로 표현

### 2) 종류

- 편항 이진 트리
  - 한 쪽 방향으로만 편향
- 포화 이진 트리
  - 트리의 높이가 일정하고 리프 노드가 꽉 찬 트리
- **완전 이진 트리**
  - 마지막 레벨을 제외하고 완전하게 노드들이 채워져 있고, 마지막 레벨은 왼쪽부터 채워진 트리
  - 코테에서 자주 사용한다.

### 3) 표현

- 1차원 배열로 표현
  - **인덱스 연산!!**

## 3. 세그먼트 트리

### 1) 세그먼트 트리(큰 범위에서는 인덱스 트리)

- **구간 합**(or 구간 최대/최소)과 **데이터 업데이트**를 빠르게 수행하기 위한 자료구조
  - 구간 합: 합배열을 이용할 수 있다.
    - 하지만! 데이터 업데이트 반영이 가장 느리다.

### 2) 핵심 이론

1. **트리 초기화 하기**

   - 데이터가 리프 노드에 다 들어갈 수 있을 만큼 공간 확보
   - 부모 노드값 채우기

2. **질의값 구하기**

   - 질의 index를 트리에 맞게 변경하기
   - `start % 2==1` 선택 → start = (start + 1)/2
   - `end % 2==0` 선택 → end = (end - 1)/2
   - start > end이면 종료

3. **데이터 업데이트 하기**

   - 트리 특성을 살려 부모로 가면서(index/2) 업데이트

## 4. LCA(최소 공통 조상)

### 1) 일반적인 LCA 구하기

- 트리의 높이가 크지 않을 때, 데이터가 많지 않을 때
- 방법
  - 시간 제한이 타이트하지 않을 때
- 루트 노드에서 탐색을 시작해 각 노드의 **부모 노드의 깊이**를 저장한다.
  - BFS, DFS 이용
- `LCA(node1, node2)`
  - node1, node2의 깊이가 다른 경우, 더 깊은 노드의 노드를 **1칸씩** 부모 노드로 올려준다.(깊이가 같아질 때까지)
  - 두 노드의 깊이가 같은데 노드가 다르다면 둘 다 **1칸씩** 부모 노드로 올려준다.(노드가 같아질 때까지)
  - 두 노드의 깊이가 같고, 두 노드가 같다면 그 노드가 **최소 공통 조상**이다.(탐색 종료)

### 2) 응용-빠르게 구하기

- `2^k`씩 올라가는 방법으로 LCA 구하기
  - 이전 방법은 바로 위 부모 정보만 저장했지만 이 방법에서는 각 노드의 **2^k**번째 부모 정보까지 저장한다.

1. 부모노드 저장 배열 만들기

- `P[K][N] = P[K-1][P[K-1][N]]`
  - 점화식으로 각 부모 노드를 찾을 수 있다.
  - `P[K][N]`: N번 노드의 **2^K**번째 부모

2. 선택된 두 노드의 깊이 맞추기

- 두 노드의 높이가 다르다면 깊이가 더 깊은 노드를 **2^K** (< 높이 차이) 만큼 이동한다.(높이 차이가 같아질 때까지 진행)

3. 최소 공통 조상 찾기

- 두 노드가 같아졌다면 K를 감소하면서 두 노드가 달라지는 시점을 찾는다.(K가 0이 될 때까지)
  - 반복문이 종료된 후 두 노드가 같다면 그 노드가 최소 공통 조상이다.
  - 반복문이 종료된 후 두 노드가 다르다면 바로 위의 노드가 최소 공통 조상이다.
