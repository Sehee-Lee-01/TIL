> 이 글은 [백준 1753번](https://www.acmicpc.net/problem/1753)을 풀고 기록한 글입니다.

# 풀이 후기

## 왜 `HashMap` 시간초과, 메모리 초과가 나고 `LinkedList`로는 통과하는 것일까?

### 상황

- 간선의 정보를 저장할 때 `HashMap`을 사용하면 시간초과, 메모리 초과가 나고 `LinkedList`를 사용하면 통과한다.

### 의도

- 각 노드의 간선이 중복 가능성이 있다고 해서 간선 중복을 피하고자 HashMap 구조로 가장 최소 거리의 간선만 남기려고 하였다.
  - 예를 들어 [노드1 → 노드3] 으로 가는 간선이 2개 있다고 해보자 하나는 값이 1이고 하나는 값이 2이다. 나는 이 중에서 값이 1인 간선만 남기려고 했다.
  - 간선 정보를 저장하는 단계에서 Map 구조를 이용해 기존에 간선이 저장된 것이 있는지 있다면 지금 저장할 간선 거리가 이미 저장된 값보다 작은지 확인하고 작다면 간선 정보를 갱신하려고 했다. 즉, 기존 간선의 정보를 확인하기 위해(간선 중복이 많아질까봐) Map 구조를 이용했다.
- **하지만 이렇게 하니까 시간초과, 메모리 초과가 났다. 그래서 단순하게 중복을 고려하지않고 LinkedList로 바꿔서 모든 간선을 저장하여 풀었더니 통과했다.**
  - LinkedList로 푸는 것도 생각 했지만 간선의 많은 중복을 피하고자 Map 구조를 사용하려고 했다.
  - 최단거리를 확인하는 과정에서 간선이 많으면 의미없는 반복이 생길 수도 있기 때문이다. 그래서 가장 최단 거리만 남기고자 위처럼 풀이했다.

### 분석

```
# 중복 고려 없이 단순하게 LinkedList 저장
LinkedList add : 115ms
LinkedList daik : 1ms

# 중복 확인하고 HashMap 저장
HashMap add : 273ms
HashMap daik : 0ms
```

- 두 방식의 시간 차이를 분석해 보았다.

  - 간선을 저장하는 과정 에서는 LinkedList가 HashMap보다 빠르다.(중복 확인을 하지 않기 때문에)
  - 다익스트라 알고리즘을 적용하는 과정에서는 시간 차이가 거의 없었다. HashMap 조금 빠르게 나오긴 했다.

  - HashMap

    - add

      - 일단 getorDefault 메소드로 확인한다. `최소 O(1)`
        - 없다면 저장한다. `O(1)`
        - 있다면 비교하고 저장한다. `O(1)`
        - 저장할 필요가 없으면 넘어간다.

    - daik

      - 현 노드에서 연결된 노드들과 그 가중치를 확인하고 비교한다.`O(연결된 노드 개수)`

  - LinkedList

    - add

      - 일단 저장한다. `O(1)`

    - daik
      - 현 노드에서 연결된 노드들과 그 가중치를 확인하고(중복 있음) 비교한다. `O(연결된 노드 개수 + 그 외 중복된 간선 개수)`

### 결론

- 간선을 저장하는 과정에서 중복을 확인하는 것이 큰 차이를 보이긴 했던 것 같다. Map get 메소드에서 꼭 O(1)이 아닐 수도 있다는 글을 보았다.
  - **HashMap 방식은 추가적인 연산이 있었기 때문에 더 시간이 늘어났다.**
- 다익스트라에서는 시간 복잡도가 상수 차이이기 대문에 거의 유사한 것을 볼 수 있다. 그래서 큰 차이가 없었던 것으로 보인다.
  - **가장 차이가 날 것 같았던 과정에서 가장 차이가 없었다!!** 굳이 걱정하며 HashMap으로 풀 필요가 없었다.

### 참고

- [[자료구조] 그래프 - HashMap을 이용한 인접리스트 구현?](https://velog.io/@duf7040/%EC%9E%90%EB%A3%8C%EA%B5%AC%EC%A1%B0-%EA%B7%B8%EB%9E%98%ED%94%84-HashMap%EC%9D%84-%EC%9D%B4%EC%9A%A9%ED%95%9C-%EC%9D%B8%EC%A0%91%EB%A6%AC%EC%8A%A4%ED%8A%B8-%EA%B5%AC%ED%98%84)
