# 그래프

> [Do it! 알고리즘 코딩테스트 with JAVA](https://inf.run/yax9)를 수강하며 기록했습니다.

## 1. 그래프의 표현

총 3가지 방법이 있다.

### 1) 에지 리스트

- `에지`를 중심으로 표현한다.
- 노드 중심 알고리즘에 사용하기는 어렵다.
  - ex) 2번 노드와 연결된 노드 찾기: 노드 리스트에서 정렬하고.. 일일이 탐색하고...(시간 복잡도 ↑)
- 벨만 포드, 크루스칼 알고리즘에 주로 사용: 에지 중심 알고리즘

### 2) 인접 행렬

- N\*N 2차원 배열에 노드 연결 정보 기록
  - 인덱스를 이용하여 시작노드와 도착 노드를 표현
- 구현은 쉬우나 시간 복잡도↑(에지 탐색), 공간 복잡도↑(N\*N 2차원 배열)
  - 노드 개수에 따라 사용 여부 판별

### 3) **🌟인접 리스트**

- 효율적인 방법이다.
  - 구조는 상대적으로 복잡하지만 에지 탐색 시간이 매우 뛰어나다.
- **가중치 없을 때:** `ArrayList<Integer> [N]`으로 선언
  - List 자료구조의 가변적인 특징을 이용
- **가중치 있을 때:** `ArrayList<Node> [N]`으로 선언
  - 시작노드는 인덱스로 표현
  - `Node` 클래스를 직접 만든다.(안의 속성은 가중치와 끝 노드 정보 저장)

### 4) 예제: 이분 그래프 판별하기(백준 1707)

- 문제가 복잡할 땐 일단 읽고 테스트 케이스로 이해하기
- 특수 자료구조에 대한 배열을 만들고 싶다면 그 배열 요소 하나하나 초기화 시켜주기

---

## 2. 유니온 파인드

- 그래프의 **사이클** 유무 판별

### 1) 원리

- 초기화
  - 대표노드 저장 배열: 처음에는 자기 자신 저장

### 2) 🌟두 개의 연산

- `union()`: 노드 연결, 대표 노드 변경
  - 현재 노드의 `대표 노드`끼리 연결해준다.
- `find()`: 자신의 대표 노드 찾기
  - 대표 노드 배열에서 탐색(현재 노드 == 대표노드): 재귀
  - 그래프를 `정돈(업데이트)`하고 시간 복잡도 개선(**경로 압축**)

### 3) 예제: 집합의 표현(백준 1717)

---

## 3. 위상 정렬

- `사이클이 없고` `방향이 있는` 그래프일 때 `노드 정렬`(노드 순서를 찾는다.)

  - ex) 수강신청(수1 → 수2)처럼 선후 관계가 필요한 경우
    - 정렬 결과가 1개가 아니다.

- `O(노드 수 + 에지 수)`

### 1) 원리

- **인접 리스트, 진입차수, 위상 정렬 배열** 배열 초기화
  - `진입 차수`: 자기 자신을 가리키는 에지의 개수
- 진입 차수가 0인 노드부터 방문 하고 위상 정렬 배열에 넣는다.
  - 연결된 노드의 진입차수를 1씩 빼준다.
  - 다시 진입 차수가 0인 노드 부터 방문하여 반복한다.

### 2) 예제: 줄 세우기(백준 2252)

---

## 4. 최단 거리 알고리즘1: 다익스트라

- `시작점이 있고`, `다른 모든 노드로 가는 최단 거리`를 구하는 알고리즘
  - `음수 간선`이 있으면 안된다.
- `O(ElogV)`: 노드 수는 V, 에지 수는 E

### 1)핵심 이론 5단계

- **인접 리스트로 그래프 구현하기**

  - 데이터를 자료구조에 저장

- **최단 거리 배열 초기화하기**

  - 시작 노드는 0, 나머지는 무한대 크기로 초기화

- **값이 가장 작은 노드 구하기**

  - 최단 거리 배열에서 가장 작은 값을 골라준다.

- **최단 거리 배열 업데이트 하기**

  - 최단 거리 배열과 현재 연결된 노드 사이의 거리를 비교하며 업데이트

- **과정 3,4를 반복하여 최단 거리 배열 완성하기**
  - 갔던 곳 다시 가지 않도록 방문 처리

---

## 5. 최단 거리 알고리즘2: 벨만-포드

- `시작점이 있고`, `다른 모든 노드로 가는 최단 거리`를 구하는 알고리즘
  - `음수 간선`도 가능하다.
- 최근에는 `음수 사이클`이 있는지 체크하는 문제가 나올 때도 있음(- 무한대)
  - 시간여행(웜홀) 문제
- O(VE)

### 1) 핵심이론

1. **에지 리스트**로 그래프를 구현하고, **최단 경로 리스트** 초기화하기

- 에지 중심으로 동작하므로 노드별 인접리스트가 아니라 에지 리스트로 그래프 구현
- 각 노드별 최단 경로 거리를 저장할 리스트 초기화
  - 출발 노드는 값을 0으로 초기화

2. 모든 에지를 확인해 **정답 리스트 업데이트** 하기

- **최단 거리 리스트 업데이트 횟수**는 음수 사이클이 없는 한 최대 (노드 개수 -1)
  - 최단 거리가 무한대가 아닌 노드를 탐색한다. 이후 값을 비교해서 리스트 업데이트
- 해당 업데이트에서 시작 점에서 각 노드에 대한 최단거리는 업데이트 된 그 값이다.
  - 업데이트 n번째 = 시작점에서 n 개의 엣지를 사용했을 때 각 노드의 최단거리

3. **음수 사이클** 유무 확인하기

- 모든 에지를 다시 사용해 업데이트되는 노드가 발생하는지 확인

---

## 6. 최단 거리 알고리즘3: 플로이드 워셜

- `시작점이 없고`, 모든 노드쌍에 대해서 최단 거리를 구하는 알고리즘
- O(V^3)
  - 시간 복잡도가 높다.
  - 노드의 수가 적을 때 사용

### 1) 핵심 이론

- A 노드에서 B 노드까지 최단 경로를 구했다고 가정 했을 때, 최단 경로 위에 K 노드가 존재한다면, 그것을 이루는 부분 경로 역시 최단 경로이다.

### 2) 3단계

1. 리스트를 선언하고 초기화하기

- 최단 거리를 저장하는 리스트를 정의한다.(인접 행렬)
  - S == E이면 값을 0, 반대이면 무한대로 설정

2. 최단 거리 리스트에 그래프 데이터 저장하기

- 에지 정보를 리스트에 저장한다.

3. 점화식으로 리스트를 업데이트한다.(모든 쌍에 대한 최단 거리 표현)

- 3중 for문으로 구현한다.(K → S → E)

- `D[S][E] = Math.min(D[S][E], D[S][K] + D[K][E])`

---

## 7. 최소 신장 트리(MST)

- 그래프에서 `최소의 가중치 합`으로 `모든 노드를 연결`할 수 있는 알고리즘
- **트리**: `사이클`이 나올 수 없다. → 사이클 방지를 위해 `유니온 파인드` 이용
- 대표적으로 두 가지 방법이 있다.
  - 크루스칼(여기서 다룰 것)
  - 프림
- 사이클을 포함하지 않는다.
  - N개의 노드가 있다면 최소 신장 트리를 구성하는 에지의 개수는 항상 N-1개다.

### 1) 핵심 이론(크루스칼)

1. **에지 리스트**로 그래프를 구현하고 **유니온 파인드 리스트** 초기화하기

- 에지 중심으로 데이터를 저장한다.
- 유니온 파인드는 사이클 판별을 위해 사용한다.

2. 그래프 데이터를 **가중치 기준**으로 정렬한다.

3. **가중치가 낮은 에지**부터 연결을 시도한다.

- 사이클이 되는지 안되는지를 확인하고 계속 연결을 시도한다.

4. 에지의 개수가 N-1이 될 때까지 3번 단계를 반복한다.

5. 총 에지 비용을 출력한다.
