# 비동기/동기

- 📖참고자료
  - [https://hazel-developer.tistory.com/179](https://hazel-developer.tistory.com/179)
  - [https://velog.io/@kim*unknown*/JavaScript-Asynchronous](https://velog.io/@kim_unknown_/JavaScript-Asynchronous)
  - [https://www.youtube.com/watch?v=e9f1TyIlAzs](https://www.youtube.com/watch?v=e9f1TyIlAzs)
    - 동기/비동기 관련 영상만 시청
  - [https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing](https://developer.mozilla.org/en-US/docs/Learn/JavaScript/Asynchronous/Introducing)

## 1. JS는 동기 언어이다.

- 추가적으로 blocking, single-thread 특징을 가지고 있다.
- single-thread이기 때문에 한 번에 한 작업만 한다. → 동기적으로 코드를 처리한다.

## 2. 다만, JS는 비동기식으로 동작하도록 조작할 수 있기 때문에 비동기 언어로 착각하곤 한다!

- 비동기로 동작하는 핵심 요소는 자바스크립트 런타임이 가지고 있다.
- 자바스크립트 언어 자체가 비동기 특성을 제공하는 것이 아닌 브라우저의 구성 요소들이 비동기 특성을 만들어낸다.
  - 일반 평범한(?) 코드를 작성할 때는 동기식으로 프로그램이 실행된다. 다만 **특정 API, 함수**를 사용할 경우에는 마치 JS가 비동기식 언어처럼 보이는 상황이 벌어진다. 비동기식으로 작업을 처리할 수 있게 된다.
    - 브라우저 환경에서는 이벤트 루프, 매크로태스크 큐(=태스트 큐), 마이크로태스크 큐(= 잡 큐) 등으로 구성된 모듈이 있는데 이에 대한 작동 방식을 보면 이해할 수 있다.

## 3. 일단, JS의 대표적인 비동기 내장 함수를 알아보자.

- 인터넷 통신에서는 비동기 처리 방식이 필요하다. 요청을 보내면 네트워크 환경에 따라, 외부 요소에 따라 응답을 언제 받을 지 모른다. 이런 상황에서 응답을 받을 때까지 기다리면 일을 처리하는 효율이 떨어진다. 그렇기 때문에 이런 비동기 방식이 인터넷 통신 등에는 필요하다.
- 대표적인 비동기 내장 함수는 setTimeout, XMLHttpRequest, fetch가 있다.
  - setTimeout 함수를 제외하고는 인터넷 통신과 관련된 함수이다!
- 아래는 자주 접하는 비동기 방식 사례이다.
  - 웹 사이트에서의 사용자 행동 감지(버튼을 눌렀을 때 등)
  - 웹 요청에 대한 응답(n초 후 응답을 받았을 때)

## 4. JS 비동기 내장 함수를 써보자! (비동기 작업을 접해보자!)

- 위 참고자료 기존 개념을 통해서 비동기 내장 함수를 사용하면 JS가 비동기식 언어처럼 작동한다는 것을 알게 되었다. 언제 돌아올지 모르는 응답, 리턴이 발생하면 이후에 어떻게 해야 잘 처리할 수 있을지 생각해보자!
- 쇼핑몰 이용 예시
  | 비동기 작업 종류 | 주문하기 | 제품 검색하기 |
  | ---------------- | ------------------------------- | ----------------------------- |
  | 하위 작업1 | 장바구니에 물건 담기 | 제품명 검색 |
  | 하위 작업2 | 장바구니에 담긴 물건을 주문하기 | 검색 리스트 중 찾는 제품 선택 |
  | 하위 작업3 | 주문한 물건들을 배송한다. | |

  - 쇼핑몰을 이용 한다고 생각해보자. 크게 위 두 가지 작업을 한다고 가정하자. 각각은 언제 끝날지 모르지만 각각의 순서대로 진행해야 하는 \*\*\*\*하위 작업이 있다.
    - 그렇기 때문에 두 작업도 각각 언제 끝날지 모른다.
  - 위 두 가지 작업들이 실행하는 순서는 어떻게 되든 중요하지 않지만, 각 하위 작업들이 순서대로(헷갈리겠지만, 동기적으로) 발생해야 뭔가 정상적인 과정이 될 것이다.
  - 잘못된 예시

    - 주문하기, 제품 검색하기는 순서가 상관없어서 내가 임의로 [주문하기 → 제품 검색하기] 순으로 하위 작업을 나열했다.
    - 각 하위 작업들은 언제 동안 처리될지 모르기 때문에 시간을 랜덤 값으로 두고 setTimeout 함수를 이용해서 각 하위 작업을 표현했다!
      - 작업이 언제 끝날지 모르기 때문에 그냥 console.log만 쓰지 않았다는 것이 포인트이다!
    - 그리고 각 작업의 하위 작업들은 순차적으로 일어나야 하니 순서대로 코드를 썼다.

      ```jsx
      // 잘못된 예시
      // 작업 1
      setTimeout(
        () => console.log("장바구니에 물건을 담는다."),
        1000 * Math.random()
      );
      setTimeout(
        () => console.log("장바구니 물건을 주문한다."),
        1000 * Math.random()
      );
      setTimeout(
        () => console.log("주문한 물건들을 배송한다."),
        1000 * Math.random()
      );

      // 작업 2
      setTimeout(() => console.log("제품명 검색"), 1000 * Math.random());
      setTimeout(
        () => console.log("검색 리스트 중 찾는 제품 선택."),
        1000 * Math.random()
      );
      // 출력
      // 각 하위 작업의 대기 시간이 끝난 순서대로(각각 1000*Math.random() 동안 기다린 후) 나온다.
      ```

    - 이런! 순서대로 나와야 할 **하위 작업**들이 원하는 순서대로 나오지 않고 뒤죽박죽 나온다!

  - 각 하위 작업이 언제 끝날지 모르지만 연속적으로(순서대로) 각각의 일을 처리하고 싶다! 그렇기 위해선 이런 비동기 작업들이 질서가 생기도록 해주는 방식을 알아야 한다.
    - 두 작업 순서는 상관없지만, **\***각 작업에서 하위 작업 순서를 지키려면**\*** 어떻게 해야할까?

  ## 5. JS에서 비동기 함수를 구현하고 다뤄보자.

  - 아이러니 하게도 JS는 동기식 언어이지만 종종 비동기 작업을 다루기 위해 비동기 내장 함수를 사용하고 이를 다뤄야 할 일이 생긴다. 위의 예시처럼 비동기 환경에서 어떤 특정 일이 끝나면 특정한 일이 연쇄적으로 일어나게 하고 싶을 것이다. 이럴 때 필요한 것이 비동기 함수이다!

    - 동기 함수라고 한다면 아래와 같은 예시가 아닐까!

      ```jsx
      // 바로 위에서 아래로 동작한다.
      function sync() {
        let a = 10; // 1
        let b = 20; // 2
        let sum = a + b; // 3
        return sum; // 4
      }

      // 비교해보자 -> 비동기 환경에서는 순서를 모른다!
      setTimeout(
        () => console.log("장바구니에 물건을 담는다."),
        1000 * Math.random()
      ); // ?
      setTimeout(
        () => console.log("장바구니 물건을 주문한다."),
        1000 * Math.random()
      ); // ?
      setTimeout(
        () => console.log("주문한 물건들을 배송한다."),
        1000 * Math.random()
      ); // ?
      ```

  ### 1) callback

  - 이럴 때 사용하는 방법 중 하나가 콜백 함수이다.

    ```jsx
    // 편의상 함수명은 다 한글이다.
    // 작업 1에 대한 하위 작업 함수 정의
    function 물건담기(callback) {
      setTimeout(() => {
        console.log("주문하기1: 장바구니에 물건을 담는다.");
        callback(); // 물건 담기 하위 작업이 끝난 후 실행하는 함수.
      }, 1000 * Math.random());
    }
    function 물건주문(callback) {
      setTimeout(() => {
        console.log("주문하기2: 장바구니 물건을 주문한다.");
        callback(); // 물건 주문 하위 작업이 끝난 후 실행하는 함수.
      }, 1000 * Math.random());
    }
    function 물건배송() {
      setTimeout(() => {
        console.log("주문하기3: 주문한 물건들을 배송한다.");
      }, 1000 * Math.random());
    }

    // 작업 2에 대한 하위 작업 함수 정의
    function 제품검색(callback) {
      setTimeout(() => {
        console.log("제품검색1: 제품명 검색");
        callback(); // 제품 검색 하위 작업이 끝난 후 실행하는 함수.
      }, 1000 * Math.random());
    }
    function 제품선택() {
      setTimeout(() => {
        console.log("제품검색2: 검색 리스트 중 찾는 제품 선택.");
      }, 1000 * Math.random());
    }

    // ---------------------------- 함수 실행 ------------------------
    // 작업1 ,작업2의 끝나는 순서는 모르지만 하위 작업만 순서대로 놓는 방법!
    // 작업 1
    물건담기(() => 물건주문(() => 물건배송()));

    // 작업2
    제품검색(() => 제품선택(() => 물건담기()));
    ```

  - 하지만 하위 작업이 더 많아진다고 생각하면 함수가 복잡해진다.
    - 콜백 지옥이 기다린다.
